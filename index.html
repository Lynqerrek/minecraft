<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Mini Voxel — Play</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial}
    #hud{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.35);color:#fff;padding:8px 10px;border-radius:8px;z-index:10;font-size:13px;min-width:180px}
    #hint{opacity:0.9;font-size:12px}
    #sel{font-weight:700;margin-top:6px}
    #canvas-holder{width:100%;height:100%}
  </style>
</head>
<body>
  <div id="hud">
    <div id="hint">Click to play — Left: remove • Right: place • 1-5: change block • WASD: move • Space: jump</div>
    <div id="sel">Selected: </div>
  </div>
  <div id="canvas-holder"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.154.0/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/PointerLockControls.js';

    const CONFIG = {
      blockSize: 1,
      worldSize: 48,
      maxHeight: 14,
      skyColor: 0x87ceeb,
      gravity: -20,
      jumpSpeed: 8,
    };

    const BLOCK_TYPES = [
      { id: 0, name: 'Dirt', color: 0x8B5A2B },
      { id: 1, name: 'Grass', color: 0x4CAF50 },
      { id: 2, name: 'Stone', color: 0x8A8A8A },
      { id: 3, name: 'Sand', color: 0xEED6A7 },
      { id: 4, name: 'Water', color: 0x3FA7D6, transparent: true, opacity:0.6 },
    ];

    let scene, camera, renderer, raycaster, mouse;
    let controlsFP, clock;
    let blockGroup;
    let blocks = new Map();
    let currentBlockType = BLOCK_TYPES[1];

    const canvasHolder = document.getElementById('canvas-holder');
    const selEl = document.getElementById('sel');

    selEl.textContent = `Selected: ${currentBlockType.name} (1-${BLOCK_TYPES.length})`;

    function init(){
      scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.skyColor);
      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias:true }); renderer.setSize(innerWidth, innerHeight); renderer.shadowMap.enabled=true; canvasHolder.appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9); scene.add(hemi);
      const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(50,80,50); sun.castShadow=true; scene.add(sun);

      controlsFP = new PointerLockControls(camera, renderer.domElement);
      renderer.domElement.addEventListener('click', ()=>{ controlsFP.lock(); });
      controlsFP.addEventListener('lock', ()=>{ document.getElementById('hint').style.display='none'; });
      controlsFP.addEventListener('unlock', ()=>{ document.getElementById('hint').style.display='block'; });

      raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2();
      window.addEventListener('resize', onWindowResize);
      renderer.domElement.addEventListener('contextmenu', e=>e.preventDefault());
      renderer.domElement.addEventListener('pointerdown', onPointerDown);

      blockGroup = new THREE.Group(); scene.add(blockGroup);

      // big ground to catch clicks
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x2f7a2f}));
      ground.rotation.x = -Math.PI/2; ground.position.y = -2; ground.receiveShadow=true; scene.add(ground);

      clock = new THREE.Clock();

      // movement
      initMovement();

      // generate and spawn
      generateTerrain();
      const spawnX = 0, spawnZ = 0;
      const spawnY = getHighestBlockAt(spawnX, spawnZ) + 2.2;
      controlsFP.getObject().position.set(spawnX, spawnY, spawnZ);
      camera.position.set(spawnX, spawnY, spawnZ);

      animate();
    }

    function onWindowResize(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }

    // Simple deterministic noise
    function seededRandom(x){ let s = Math.sin(x)*10000; return s - Math.floor(s); }
    function valueNoise2D(x,z){ const x0=Math.floor(x), z0=Math.floor(z); const xf=x-x0, zf=z-z0;
      const v00=seededRandom(x0*374761393+z0*668265263); const v10=seededRandom((x0+1)*374761393+z0*668265263);
      const v01=seededRandom(x0*374761393+(z0+1)*668265263); const v11=seededRandom((x0+1)*374761393+(z0+1)*668265263);
      const ix0 = v00*(1-xf)+v10*xf; const ix1 = v01*(1-xf)+v11*xf; return ix0*(1-zf)+ix1*zf; }
    function getHeightAt(x,z){ const s=0.12; let h=0; h += valueNoise2D(x*s,z*s)*5; h += valueNoise2D(x*s*2,z*s*2)*2; h += valueNoise2D(x*s*4,z*s*4)*1; h = Math.floor(h); return Math.max(1, Math.min(CONFIG.maxHeight, h+2)); }

    function keyFor(x,y,z){ return `${x},${y},${z}`; }
    function addBlock(x,y,z,type=null){ if(type===null) type=currentBlockType; const k=keyFor(x,y,z); if(blocks.has(k)) return null; const geo=new THREE.BoxGeometry(CONFIG.blockSize,CONFIG.blockSize,CONFIG.blockSize);
      const matOpts={color:type.color}; if(type.transparent){ matOpts.transparent=true; matOpts.opacity=type.opacity??0.6; }
      const mat=new THREE.MeshStandardMaterial(matOpts); const mesh=new THREE.Mesh(geo,mat); mesh.position.set(x*CONFIG.blockSize, y*CONFIG.blockSize, z*CONFIG.blockSize); mesh.castShadow=true; mesh.receiveShadow=true; blockGroup.add(mesh); blocks.set(k,{mesh,type}); return mesh; }
    function removeBlock(x,y,z){ const k=keyFor(x,y,z); const v=blocks.get(k); if(!v) return false; blockGroup.remove(v.mesh); if(v.mesh.geometry) v.mesh.geometry.dispose(); if(v.mesh.material) v.mesh.material.dispose(); blocks.delete(k); return true; }
    function clearWorld(){ for(const [k,v] of blocks){ blockGroup.remove(v.mesh); if(v.mesh.geometry) v.mesh.geometry.dispose(); if(v.mesh.material) v.mesh.material.dispose(); } blocks.clear(); }

    function generateTerrain(){ clearWorld(); const half=Math.floor(CONFIG.worldSize/2); for(let x=0;x<CONFIG.worldSize;x++){ for(let z=0;z<CONFIG.worldSize;z++){ const wx = x-half, wz = z-half; const h = getHeightAt(wx,wz); for(let y=0;y<h;y++){ let type = BLOCK_TYPES[0]; if(y===h-1) type = BLOCK_TYPES[1]; else if(y<2) type = BLOCK_TYPES[0]; else type = (y>6?BLOCK_TYPES[2]:BLOCK_TYPES[0]); addBlock(wx,y,wz,type); } if(h<3){ for(let y=h;y<3;y++) addBlock(wx,y,wz,BLOCK_TYPES[4]); } } } }

    function onPointerDown(event){ const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX-rect.left)/rect.width)*2-1; mouse.y = -((event.clientY-rect.top)/rect.height)*2+1; raycaster.setFromCamera(mouse,camera); const intersects = raycaster.intersectObjects(blockGroup.children,false);
      if(intersects.length>0){ const hit=intersects[0]; const pos = hit.object.position.clone().divideScalar(CONFIG.blockSize); const bx=Math.round(pos.x), by=Math.round(pos.y), bz=Math.round(pos.z);
        if(event.button===0){ removeBlock(bx,by,bz); }
        else if(event.button===2){ const normal = hit.face.normal.clone(); normal.applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)); const placeX=bx+Math.round(normal.x), placeY=by+Math.round(normal.y), placeZ=bz+Math.round(normal.z); addBlock(placeX,placeY,placeZ,currentBlockType); }
      } else { if(event.button===2){ const planeY = -2 + CONFIG.blockSize/2; const dir = raycaster.ray.direction; const orig = raycaster.ray.origin; const t = (planeY - orig.y)/dir.y; if(t>0){ const p = orig.clone().add(dir.clone().multiplyScalar(t)); const bx=Math.round(p.x/CONFIG.blockSize), bz=Math.round(p.z/CONFIG.blockSize); addBlock(bx,0,bz,currentBlockType); } } }
    }

    // quick lookup for highest block at x,z (integer coords)
    function getHighestBlockAt(x,z){ for(let y=CONFIG.maxHeight; y>=-10; y--){ if(blocks.has(keyFor(x,y,z))) return y; } return -10; }

    // Movement + simple gravity/collision
    const moveState = { forward:false, back:false, left:false, right:false, jump:false };
    let velocity = new THREE.Vector3();
    function initMovement(){ document.addEventListener('keydown', (e)=>{
        if(e.code==='KeyW') moveState.forward=true;
        if(e.code==='KeyS') moveState.back=true;
        if(e.code==='KeyA') moveState.left=true;
        if(e.code==='KeyD') moveState.right=true;
        if(e.code==='Space') moveState.jump=true;
        // block selection 1-5
        if(e.code.startsWith('Digit')){
          const n = parseInt(e.code.replace('Digit',''),10); if(n>=1 && n<=BLOCK_TYPES.length){ currentBlockType = BLOCK_TYPES[n-1]; selEl.textContent = `Selected: ${currentBlockType.name} (1-${BLOCK_TYPES.length})`; }
        }
      });
      document.addEventListener('keyup', (e)=>{
        if(e.code==='KeyW') moveState.forward=false;
        if(e.code==='KeyS') moveState.back=false;
        if(e.code==='KeyA') moveState.left=false;
        if(e.code==='KeyD') moveState.right=false;
        if(e.code==='Space') moveState.jump=false;
      });
    }

    function animate(){ requestAnimationFrame(animate); const dt = Math.min(0.05, clock.getDelta()); // movement
      const player = controlsFP.getObject();
      const speed = 6;
      // horizontal movement
      const dir = new THREE.Vector3(); controlsFP.getDirection(dir); dir.y = 0; dir.normalize(); const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
      let move = new THREE.Vector3(); move.add(dir.multiplyScalar((moveState.forward?1:0) - (moveState.back?1:0)));
      move.add(right.multiplyScalar((moveState.right?1:0) - (moveState.left?1:0)));
      if(move.lengthSq()>0) move.normalize().multiplyScalar(speed*dt);

      // gravity & jumping (simple world-based collision)
      const px = Math.round(player.position.x/CONFIG.blockSize); const pz = Math.round(player.position.z/CONFIG.blockSize);
      const highest = getHighestBlockAt(px,pz);
      const feetY = highest + 1.0; // y position where feet should be when standing
      // apply gravity
      velocity.y += CONFIG.gravity * dt;
      // jump if requested and on ground
      const onGround = player.position.y <= feetY + 0.05;
      if(moveState.jump && onGround){ velocity.y = CONFIG.jumpSpeed; }
      // integrate
      player.position.x += move.x; player.position.z += move.z; player.position.y += velocity.y * dt;
      // prevent sinking below ground surface
      if(player.position.y <= feetY + 0.01){ velocity.y = 0; player.position.y = feetY + 0.01; }

      camera.position.copy(player.position);
      renderer.render(scene, camera);
    }

    // start
    init();

    // expose for tinkering
    window.VOXEL = { addBlock, removeBlock, clearWorld, blocks, scene, camera };
  </script>
</body>
</html>
