<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft: Amplified + Big Biomes</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Segoe UI', sans-serif; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: transparent; 
            transform: translate(-50%, -50%); pointer-events: none;
            mix-blend-mode: difference; z-index: 10;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        #ui {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px;
            pointer-events: none; user-select: none; z-index: 5;
            font-family: monospace; text-shadow: 1px 1px 0 #000;
        }
        
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0, 0, 0, 0.5); padding: 5px; border-radius: 5px; z-index: 5;
        }
        .slot {
            width: 40px; height: 40px; border: 2px solid gray; cursor: pointer;
            image-rendering: pixelated; background-size: cover; background-color: #333;
            transition: transform 0.1s;
        }
        .active { border-color: white; transform: scale(1.1); box-shadow: 0 0 5px white; }

        #menu {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); z-index: 20; color: white;
            backdrop-filter: blur(5px);
        }
        .menu-item { margin: 15px; text-align: center; }
        button.btn {
            padding: 12px 30px; font-size: 18px; cursor: pointer;
            background: #2E7D32; color: white; border: 2px solid #4CAF50; border-radius: 5px;
            text-transform: uppercase; font-weight: bold;
        }
        button.btn:hover { background: #388E3C; }
        input[type="range"] { width: 300px; accent-color: #4CAF50; }
    </style>
    <!-- Import Maps Polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
          "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }
      }
    </script>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui">
        <b>WASD</b> Move | <b>SPACE</b> Jump | <b>ESC</b> Settings<br>
        FPS: <span id="fps">0</span> | Chunks: <span id="chunks">0</span> | Queue: <span id="queue">0</span>
    </div>
    <div id="menu">
        <h1>PAUSED</h1>
        <div class="menu-item">
            <label for="distSlider">Render Distance: <span id="distVal">5</span></label><br>
            <input type="range" id="distSlider" min="2" max="88" value="5" step="1">
        </div>
        <div class="menu-item">
            <button class="btn" id="resumeBtn">RESUME</button>
        </div>
    </div>
    <div id="hotbar"></div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { createNoise2D } from 'simplex-noise';

        // --- CONFIGURATION ---
        let renderDistance = 5;
        const CHUNK_SIZE = 16;
        const WORLD_HEIGHT = 256; 
        
        // Terrain Gen Settings
        const NOISE_SCALE = 0.0015; 
        const AMP_HEIGHT = 140;     
        const BASE_HEIGHT = 50;     

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        const chunks = new Map();
        const noise2D = createNoise2D(); 
        
        // Physics
        const velocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        let isPaused = true;
        
        // Optimization: Throttling & Caching
        let chunkQueue = []; 
        let lastChunkCheckX = -9999;
        let lastChunkCheckZ = -9999;
        
        // Smart Cache for physics to avoid Map lookups
        const chunkCache = {
            key: '',
            chunk: null
        };

        const raycaster = new THREE.Raycaster();
        const _tempVec3 = new THREE.Vector3();
        const _box3Player = new THREE.Box3();
        const _box3Block = new THREE.Box3();
        
        // Scratchpads
        const MAX_GEOM_SIZE = 500000;
        const scratchPos = new Float32Array(MAX_GEOM_SIZE * 3);
        const scratchUV = new Float32Array(MAX_GEOM_SIZE * 2);
        const scratchCol = new Float32Array(MAX_GEOM_SIZE * 3);

        const BLOCKS = { AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, LOG: 4, LEAVES: 5, PLANKS: 6 };
        
        const BLOCK_PROPS = [
            null,
            { color: '#66c246', name: 'Grass' }, 
            { color: '#8c6348', name: 'Dirt' },  
            { color: '#969696', name: 'Stone' }, 
            { color: '#5c4033', name: 'Log' },   
            { color: '#4a8a3a', name: 'Leaves', transparent: true }, 
            { color: '#dccfa3', name: 'Planks' } 
        ];

        let selectedBlock = BLOCKS.GRASS;

        // --- TEXTURES (Generated 8x8 Pixel Art) ---
        function createTextureAtlas() {
            const canvas = document.createElement('canvas');
            const size = 8; 
            canvas.width = size * (BLOCK_PROPS.length - 1);
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            BLOCK_PROPS.forEach((block, i) => {
                if (!block) return;
                const x = (i - 1) * size;
                
                // Base Color
                ctx.fillStyle = block.color;
                ctx.fillRect(x, 0, size, size);
                
                // Patterns
                if (block.name === 'Grass') {
                    ctx.fillStyle = '#8ce870'; 
                    ctx.fillRect(x + 1, 1, 2, 1); ctx.fillRect(x + 5, 2, 1, 1); ctx.fillRect(x + 2, 6, 1, 1);
                    ctx.fillStyle = '#4fa132'; ctx.fillRect(x + 1, 7, 6, 1); 
                } 
                else if (block.name === 'Dirt') {
                    ctx.fillStyle = '#6b4a34'; 
                    ctx.fillRect(x + 1, 1, 1, 1); ctx.fillRect(x + 5, 2, 1, 1);
                    ctx.fillRect(x + 2, 6, 1, 1); ctx.fillRect(x + 6, 5, 1, 1);
                } 
                else if (block.name === 'Stone') {
                    ctx.fillStyle = '#757575'; ctx.fillRect(x, 0, size, 1); ctx.fillRect(x, 0, 1, size); 
                    ctx.fillStyle = '#a8a8a8'; ctx.fillRect(x + 2, 2, 1, 1);
                } 
                else if (block.name === 'Log') {
                    ctx.fillStyle = '#4a332a'; ctx.fillRect(x + 2, 0, 1, 8); ctx.fillRect(x + 5, 0, 1, 8);
                } 
                else if (block.name === 'Leaves') {
                    ctx.fillStyle = '#3a6e2e'; ctx.fillRect(x + 1, 1, 2, 2); ctx.fillRect(x + 5, 5, 2, 2);
                    ctx.fillStyle = '#5cb849'; ctx.fillRect(x + 5, 1, 1, 1); ctx.fillRect(x + 2, 6, 1, 1);
                } 
                else if (block.name === 'Planks') {
                    ctx.fillStyle = '#bfae82'; 
                    ctx.fillRect(x, 0, size, 1); ctx.fillRect(x, 4, size, 1); 
                    ctx.fillRect(x + 3, 1, 1, 3); ctx.fillRect(x + 5, 5, 1, 3); 
                }
            });

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const atlasTexture = createTextureAtlas();
        const chunkMaterial = new THREE.MeshBasicMaterial({ 
            map: atlasTexture,
            vertexColors: true,
            side: THREE.DoubleSide
        });

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            updateFog();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);
            
            const menu = document.getElementById('menu');
            const resumeBtn = document.getElementById('resumeBtn');
            const slider = document.getElementById('distSlider');
            const distVal = document.getElementById('distVal');

            resumeBtn.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => { menu.style.display = 'none'; isPaused = false; });
            controls.addEventListener('unlock', () => { menu.style.display = 'flex'; isPaused = true; });

            slider.addEventListener('input', (e) => {
                renderDistance = parseInt(e.target.value);
                distVal.innerText = renderDistance;
                updateFog();
                lastChunkCheckX = -9999; 
                chunkQueue = []; // Clear queue on settings change
            });
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('wheel', onScroll);

            setupHotbar();
            camera.position.set(0, 150, 0); 
            
            queueChunks(true); 
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function updateFog() {
            scene.fog = new THREE.Fog(0x87CEEB, (renderDistance - 1) * CHUNK_SIZE, (renderDistance + 1) * CHUNK_SIZE);
        }

        function setupHotbar() {
            const hotbar = document.getElementById('hotbar');
            for(let i=1; i<BLOCK_PROPS.length; i++) {
                const div = document.createElement('div');
                div.className = 'slot' + (i === 1 ? ' active' : '');
                div.style.backgroundColor = BLOCK_PROPS[i].color;
                div.onclick = () => selectBlock(i);
                hotbar.appendChild(div);
            }
        }

        function selectBlock(index) {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(s => s.classList.remove('active'));
            if(slots[index-1]) {
                slots[index-1].classList.add('active');
                selectedBlock = index;
            }
        }
        
        function onScroll(e) {
            let idx = selectedBlock - 1;
            if(e.deltaY > 0) idx = (idx + 1) % (BLOCK_PROPS.length - 1);
            else idx = (idx - 1 + (BLOCK_PROPS.length - 1)) % (BLOCK_PROPS.length - 1);
            selectBlock(idx + 1);
        }

        // --- TERRAIN MATH ---
        function getTerrainHeight(x, z) {
            let n = noise2D(x * NOISE_SCALE, z * NOISE_SCALE);
            let norm = (n + 1) * 0.5; 
            let shaped = Math.pow(norm, 2.5); 
            return Math.floor(BASE_HEIGHT + (shaped * AMP_HEIGHT));
        }

        function isTreeRoot(x, z) {
            const treeNoise = noise2D(x * 0.5, z * 0.5); 
            if (treeNoise < 0.85) return false;
            const h = getTerrainHeight(x, z);
            if (h > WORLD_HEIGHT - 10) return false;
            return true;
        }

        // --- CHUNK SYSTEM ---
        
        const BOX_POS = [
            1,0,1, 1,0,0, 1,1,0, 1,1,1, // +x
            0,0,0, 0,0,1, 0,1,1, 0,1,0, // -x
            0,1,1, 1,1,1, 1,1,0, 0,1,0, // +y
            0,0,0, 1,0,0, 1,0,1, 0,0,1, // -y
            0,0,1, 1,0,1, 1,1,1, 0,1,1, // +z
            1,0,0, 0,0,0, 0,1,0, 1,1,0  // -z
        ];
        const FACE_BRIGHTNESS = [0.8, 0.8, 1.0, 0.4, 0.6, 0.6];
        const DIRS = [[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]];

        class Chunk {
            constructor(cx, cz) {
                this.cx = cx;
                this.cz = cz;
                this.data = new Uint8Array(CHUNK_SIZE * CHUNK_SIZE * WORLD_HEIGHT);
                this.mesh = null;
                this.generate();
            }

            getIndex(x, y, z) { return x + CHUNK_SIZE * (z + CHUNK_SIZE * y); }
            setBlock(x, y, z, id) { if (x >= 0 && x < CHUNK_SIZE && z >= 0 && z < CHUNK_SIZE && y >= 0 && y < WORLD_HEIGHT) this.data[this.getIndex(x, y, z)] = id; }
            getBlock(x, y, z) { 
                if (x >= 0 && x < CHUNK_SIZE && z >= 0 && z < CHUNK_SIZE && y >= 0 && y < WORLD_HEIGHT) return this.data[this.getIndex(x, y, z)];
                return 0;
            }

            generate() {
                const startX = this.cx * CHUNK_SIZE;
                const startZ = this.cz * CHUNK_SIZE;
                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const h = getTerrainHeight(startX + x, startZ + z);
                        for (let y = 0; y <= h; y++) {
                            this.setBlock(x, y, z, y === h ? BLOCKS.GRASS : (y > h - 4 ? BLOCKS.DIRT : BLOCKS.STONE));
                        }
                    }
                }
                const buffer = 3; 
                for (let x = -buffer; x < CHUNK_SIZE + buffer; x++) {
                    for (let z = -buffer; z < CHUNK_SIZE + buffer; z++) {
                        if (isTreeRoot(startX + x, startZ + z)) {
                            this.drawTree(x, getTerrainHeight(startX + x, startZ + z) + 1, z);
                        }
                    }
                }
            }

            drawTree(lx, ly, lz) {
                const height = 5;
                for (let i = 0; i < height; i++) this.setBlock(lx, ly + i, lz, BLOCKS.LOG);
                for (let x = -2; x <= 2; x++) {
                    for (let y = height - 2; y <= height + 1; y++) {
                        for (let z = -2; z <= 2; z++) {
                            if (Math.abs(x) + Math.abs(y - (height - 1)) + Math.abs(z) <= 3) {
                                if (this.getBlock(lx+x, ly+y, lz+z) === BLOCKS.AIR) this.setBlock(lx+x, ly+y, lz+z, BLOCKS.LEAVES);
                            }
                        }
                    }
                }
            }

            buildMesh() {
                if (this.mesh) { this.mesh.geometry.dispose(); scene.remove(this.mesh); }

                let vIdx = 0;
                let cIdx = 0;
                let uIdx = 0;

                const numTypes = BLOCK_PROPS.length - 1;
                const uvStep = 1 / numTypes;
                const data = this.data;
                const chunkCX = this.cx * CHUNK_SIZE;
                const chunkCZ = this.cz * CHUNK_SIZE;

                // SMART OPTIMIZATION: Pre-fetch neighbors
                const nPX = chunks.get(`${this.cx+1},${this.cz}`);
                const nNX = chunks.get(`${this.cx-1},${this.cz}`);
                const nPZ = chunks.get(`${this.cx},${this.cz+1}`);
                const nNZ = chunks.get(`${this.cx},${this.cz-1}`);

                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    for (let x = 0; x < CHUNK_SIZE; x++) {
                        for (let z = 0; z < CHUNK_SIZE; z++) {
                            const block = data[x + CHUNK_SIZE * (z + CHUNK_SIZE * y)];
                            if (block === 0) continue;

                            for (let i = 0; i < 6; i++) {
                                const dx = DIRS[i][0];
                                const dy = DIRS[i][1];
                                const dz = DIRS[i][2];
                                const nx = x + dx; const ny = y + dy; const nz = z + dz;
                                
                                let visible = false;
                                
                                // Internal check
                                if (nx >= 0 && nx < CHUNK_SIZE && nz >= 0 && nz < CHUNK_SIZE) {
                                     if (ny >= 0 && ny < WORLD_HEIGHT) {
                                        const nb = data[nx + CHUNK_SIZE * (nz + CHUNK_SIZE * ny)];
                                        if (nb === 0 || BLOCK_PROPS[nb].transparent) visible = true;
                                     } else {
                                         visible = true; // Map limit
                                     }
                                } else {
                                    // Boundary check using pre-fetched neighbor chunks
                                    // This avoids isSolidGlobal map lookups inside the loop
                                    let nb = 0;
                                    let neighbor = null;
                                    
                                    if (nx < 0) neighbor = nNX;
                                    else if (nx >= CHUNK_SIZE) neighbor = nPX;
                                    else if (nz < 0) neighbor = nNZ;
                                    else if (nz >= CHUNK_SIZE) neighbor = nPZ;
                                    
                                    if (neighbor) {
                                        // Adjust coords for neighbor lookup (wrapping)
                                        const lx = (nx + CHUNK_SIZE) % CHUNK_SIZE;
                                        const lz = (nz + CHUNK_SIZE) % CHUNK_SIZE;
                                        nb = neighbor.getBlock(lx, ny, lz);
                                    }
                                    
                                    if (nb === 0 || BLOCK_PROPS[nb].transparent) visible = true;
                                }

                                if (visible) {
                                    if (vIdx + 18 >= MAX_GEOM_SIZE * 3) break; 
                                    const vOffset = i * 12;
                                    const b = FACE_BRIGHTNESS[i];
                                    const u0 = (block - 1) * uvStep;
                                    const u1 = u0 + uvStep;

                                    scratchPos[vIdx++] = x + BOX_POS[vOffset];   scratchPos[vIdx++] = y + BOX_POS[vOffset+1];   scratchPos[vIdx++] = z + BOX_POS[vOffset+2];
                                    scratchPos[vIdx++] = x + BOX_POS[vOffset+3]; scratchPos[vIdx++] = y + BOX_POS[vOffset+4]; scratchPos[vIdx++] = z + BOX_POS[vOffset+5];
                                    scratchPos[vIdx++] = x + BOX_POS[vOffset+6]; scratchPos[vIdx++] = y + BOX_POS[vOffset+7]; scratchPos[vIdx++] = z + BOX_POS[vOffset+8];
                                    scratchPos[vIdx++] = x + BOX_POS[vOffset];   scratchPos[vIdx++] = y + BOX_POS[vOffset+1];   scratchPos[vIdx++] = z + BOX_POS[vOffset+2];
                                    scratchPos[vIdx++] = x + BOX_POS[vOffset+6]; scratchPos[vIdx++] = y + BOX_POS[vOffset+7]; scratchPos[vIdx++] = z + BOX_POS[vOffset+8];
                                    scratchPos[vIdx++] = x + BOX_POS[vOffset+9]; scratchPos[vIdx++] = y + BOX_POS[vOffset+10]; scratchPos[vIdx++] = z + BOX_POS[vOffset+11];

                                    for(let k=0; k<18; k++) scratchCol[cIdx++] = b;

                                    scratchUV[uIdx++] = u0; scratchUV[uIdx++] = 0;
                                    scratchUV[uIdx++] = u1; scratchUV[uIdx++] = 0;
                                    scratchUV[uIdx++] = u1; scratchUV[uIdx++] = 1;
                                    scratchUV[uIdx++] = u0; scratchUV[uIdx++] = 0;
                                    scratchUV[uIdx++] = u1; scratchUV[uIdx++] = 1;
                                    scratchUV[uIdx++] = u0; scratchUV[uIdx++] = 1;
                                }
                            }
                        }
                    }
                }

                // Slice creates a copy, which is necessary to avoid overwriting.
                // This copy is the fastest way to get data to GPU in standard Three.js
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(scratchPos.slice(0, vIdx), 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(scratchUV.slice(0, uIdx), 2));
                geometry.setAttribute('color', new THREE.BufferAttribute(scratchCol.slice(0, cIdx), 3));
                
                this.mesh = new THREE.Mesh(geometry, chunkMaterial);
                this.mesh.position.set(chunkCX, 0, chunkCZ);
                this.mesh.matrixAutoUpdate = false; 
                this.mesh.updateMatrix();
                scene.add(this.mesh);
            }
        }

        // --- GLOBAL WORLD HELPERS WITH CACHE ---
        
        // Smart Chunk Lookup (Used primarily by physics)
        function getChunk(cx, cz) {
            const key = `${cx},${cz}`;
            // Cache Hit
            if (chunkCache.key === key) {
                return chunkCache.chunk;
            }
            // Cache Miss
            const chunk = chunks.get(key);
            if (chunk) {
                chunkCache.key = key;
                chunkCache.chunk = chunk;
            }
            return chunk;
        }

        // Physics Solidity Check - Treats all blocks as collidable
        function isCollidableGlobal(x, y, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            
            const chunk = getChunk(cx, cz); // Uses Smart Cache
            if (!chunk) return false;
            
            let lx = x % CHUNK_SIZE; if(lx < 0) lx += CHUNK_SIZE;
            let lz = z % CHUNK_SIZE; if(lz < 0) lz += CHUNK_SIZE;
            
            const b = chunk.getBlock(lx, y, lz);
            return b !== 0;
        }

        function setBlockGlobal(x, y, z, id) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const key = `${cx},${cz}`;
            const chunk = chunks.get(key);
            if (chunk) {
                let lx = x % CHUNK_SIZE; if(lx < 0) lx += CHUNK_SIZE;
                let lz = z % CHUNK_SIZE; if(lz < 0) lz += CHUNK_SIZE;
                chunk.setBlock(lx, y, lz, id);
                chunk.buildMesh();
                // Update neighbors logic remains same (less frequent)
                if (lx === 0) updateChunkMesh(cx - 1, cz);
                if (lx === CHUNK_SIZE - 1) updateChunkMesh(cx + 1, cz);
                if (lz === 0) updateChunkMesh(cx, cz - 1);
                if (lz === CHUNK_SIZE - 1) updateChunkMesh(cx, cz + 1);
            }
        }
        function updateChunkMesh(cx, cz) {
            const chunk = chunks.get(`${cx},${cz}`);
            if (chunk) chunk.buildMesh();
        }

        // --- UPDATE LOOP WITH THROTTLING ---
        function queueChunks(force = false) {
            const px = Math.floor(camera.position.x / CHUNK_SIZE);
            const pz = Math.floor(camera.position.z / CHUNK_SIZE);

            if (!force && px === lastChunkCheckX && pz === lastChunkCheckZ) return;
            lastChunkCheckX = px;
            lastChunkCheckZ = pz;

            // Rebuild queue
            chunkQueue = [];
            for (let x = -renderDistance; x <= renderDistance; x++) {
                for (let z = -renderDistance; z <= renderDistance; z++) {
                    // Pre-calc dist squared
                    const d2 = x*x + z*z;
                    if (d2 > renderDistance*renderDistance) continue;
                    
                    const cx = px + x;
                    const cz = pz + z;
                    const key = `${cx},${cz}`;
                    if (!chunks.has(key)) {
                        chunkQueue.push({cx, cz, dist: d2});
                    }
                }
            }
            chunkQueue.sort((a, b) => a.dist - b.dist);
            
            let removals = 0;
            // Limit removals per frame to spread load
            for (const [key, chunk] of chunks.entries()) {
                if (removals > 2) break; 
                if (Math.abs(chunk.cx - px) > renderDistance + 2 || Math.abs(chunk.cz - pz) > renderDistance + 2) {
                    scene.remove(chunk.mesh);
                    chunk.mesh.geometry.dispose();
                    chunks.delete(key);
                    removals++;
                }
            }
        }

        function processChunkQueue() {
            if (chunkQueue.length === 0) return;
            const c = chunkQueue.shift();
            const key = `${c.cx},${c.cz}`;
            if (!chunks.has(key)) {
                const chunk = new Chunk(c.cx, c.cz);
                chunks.set(key, chunk);
                chunk.buildMesh();
            }
            document.getElementById('queue').innerText = chunkQueue.length;
        }

        // --- PHYSICS & INPUT ---
        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if(canJump) { velocity.y = 13; canJump = false; } break;
                case 'Digit1': selectBlock(1); break;
                case 'Digit2': selectBlock(2); break;
                case 'Digit3': selectBlock(3); break;
                case 'Digit4': selectBlock(4); break;
                case 'Digit5': selectBlock(5); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        function onMouseDown(e) {
            if(!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const meshes = [];
            for(const c of chunks.values()) if(c.mesh) meshes.push(c.mesh);
            const intersects = raycaster.intersectObjects(meshes);
            if(intersects.length > 0) {
                const hit = intersects[0];
                const bx = Math.floor(hit.point.x - hit.face.normal.x * 0.5);
                const by = Math.floor(hit.point.y - hit.face.normal.y * 0.5);
                const bz = Math.floor(hit.point.z - hit.face.normal.z * 0.5);
                if(e.button === 0) setBlockGlobal(bx, by, bz, BLOCKS.AIR);
                else if(e.button === 2) {
                    const px = Math.floor(hit.point.x + hit.face.normal.x * 0.5);
                    const py = Math.floor(hit.point.y + hit.face.normal.y * 0.5);
                    const pz = Math.floor(hit.point.z + hit.face.normal.z * 0.5);
                    _box3Player.setFromCenterAndSize(camera.position, _tempVec3.set(0.6, 1.8, 0.6));
                    _box3Block.min.set(px, py, pz);
                    _box3Block.max.set(px+1, py+1, pz+1);
                    if(!_box3Player.intersectsBox(_box3Block)) setBlockGlobal(px, py, pz, selectedBlock);
                }
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- OPTIMIZED COLLISION LOGIC ---
        function checkWall(x, y, z) {
            const r = 0.3; 
            const levels = [y - 0.8, y + 0.1]; 
            for (let ly of levels) {
                if (isCollidableGlobal(Math.floor(x + r), Math.floor(ly), Math.floor(z + r))) return true;
                if (isCollidableGlobal(Math.floor(x - r), Math.floor(ly), Math.floor(z + r))) return true;
                if (isCollidableGlobal(Math.floor(x + r), Math.floor(ly), Math.floor(z - r))) return true;
                if (isCollidableGlobal(Math.floor(x - r), Math.floor(ly), Math.floor(z - r))) return true;
            }
            return false;
        }

        function checkFloor(x, y, z) {
            const r = 0.3;
            const yCheck = Math.floor(y - 0.01); 
            if (isCollidableGlobal(Math.floor(x + r), yCheck, Math.floor(z + r))) return true;
            if (isCollidableGlobal(Math.floor(x - r), yCheck, Math.floor(z + r))) return true;
            if (isCollidableGlobal(Math.floor(x + r), yCheck, Math.floor(z - r))) return true;
            if (isCollidableGlobal(Math.floor(x - r), yCheck, Math.floor(z - r))) return true;
            return false;
        }

        // --- GAME LOOP ---
        let lastFrame = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - lastFrame) / 1000, 0.05); 
            lastFrame = time;
            
            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 32.0 * delta; 

                const speed = 150.0;
                const forward = Number(moveForward) - Number(moveBackward);
                const strafe = Number(moveRight) - Number(moveLeft);
                
                _tempVec3.setFromMatrixColumn(camera.matrix, 0); 
                if (strafe) {
                    velocity.x += _tempVec3.x * strafe * speed * delta;
                    velocity.z += _tempVec3.z * strafe * speed * delta;
                }
                _tempVec3.crossVectors(camera.up, _tempVec3);
                if (forward) {
                    velocity.x += _tempVec3.x * forward * speed * delta;
                    velocity.z += _tempVec3.z * forward * speed * delta;
                }

                const eyeHeight = 1.6;
                const originalX = camera.position.x;
                const originalZ = camera.position.z;

                // 1. Move X
                camera.position.x += velocity.x * delta;
                if (checkWall(camera.position.x, camera.position.y, camera.position.z)) {
                    camera.position.x = originalX; 
                    velocity.x = 0; 
                }

                // 2. Move Z
                camera.position.z += velocity.z * delta;
                if (checkWall(camera.position.x, camera.position.y, camera.position.z)) {
                    camera.position.z = originalZ; 
                    velocity.z = 0; 
                }

                // 3. Move Y
                camera.position.y += velocity.y * delta;
                
                // Floor Check
                if (velocity.y < 0) {
                    const feetY = camera.position.y - eyeHeight;
                    if (checkFloor(camera.position.x, feetY, camera.position.z)) {
                        camera.position.y = Math.floor(feetY - 0.01) + 1 + eyeHeight;
                        velocity.y = 0;
                        canJump = true;
                    }
                } 
                else if (velocity.y > 0) {
                    const headY = camera.position.y + 0.2;
                    if (checkWall(camera.position.x, headY, camera.position.z)) { 
                         camera.position.y = Math.floor(headY) - 0.2;
                         velocity.y = 0;
                    }
                }

                if(camera.position.y < -30) {
                    camera.position.set(0, 150, 0);
                    velocity.set(0,0,0);
                    queueChunks(true); // Clear queue if teleported
                }
            }
            
            queueChunks(); // Check if we need to add to queue
            processChunkQueue(); // Build 1 chunk per frame
            
            document.getElementById('fps').innerText = Math.round(1/delta);
            document.getElementById('chunks').innerText = chunks.size;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
