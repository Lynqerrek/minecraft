<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft: Sky-Skip Optimization</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #4FC3F7; font-family: 'Segoe UI', sans-serif; }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: transparent; 
            transform: translate(-50%, -50%); pointer-events: none;
            mix-blend-mode: difference; z-index: 10;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255, 255, 255, 0.8);
        }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        #ui {
            position: absolute; top: 10px; left: 10px; color: white;
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px;
            pointer-events: none; user-select: none; z-index: 5;
            font-family: monospace; text-shadow: 1px 1px 0 #000;
        }
        
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0, 0, 0, 0.5); padding: 5px; border-radius: 5px; z-index: 5;
        }
        .slot {
            width: 40px; height: 40px; border: 2px solid gray; cursor: pointer;
            image-rendering: pixelated; background-size: cover; background-color: #333;
            transition: transform 0.1s;
        }
        .active { border-color: white; transform: scale(1.1); box-shadow: 0 0 5px white; }

        #menu {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); z-index: 20; color: white;
            backdrop-filter: blur(5px);
        }
        .menu-item { margin: 15px; text-align: center; }
        button.btn {
            padding: 12px 30px; font-size: 18px; cursor: pointer;
            background: #2E7D32; color: white; border: 2px solid #4CAF50; border-radius: 5px;
            text-transform: uppercase; font-weight: bold;
        }
        button.btn:hover { background: #388E3C; }
        input[type="range"] { width: 300px; accent-color: #4CAF50; }
        
        .opt-badge {
            display: inline-block; background: #FF9800; color: #000; 
            padding: 2px 5px; font-size: 10px; border-radius: 3px; margin-left: 5px; vertical-align: middle;
        }
    </style>
    <!-- Import Maps Polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/",
          "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
        }
      }
    </script>
</head>
<body>
    <div id="crosshair"></div>
    <div id="ui">
        <b>WASD</b> Move | <b>SPACE</b> Jump | <b>ESC</b> Settings<br>
        FPS: <span id="fps">0</span> | Chunks: <span id="chunks">0</span> | Queue: <span id="queue">0</span><br>
        <span style="color: #FF9800; font-size: 11px;">[SKY-SKIP + PHASED LOAD + VERTEX AO]</span>
    </div>
    <div id="menu">
        <h1>PAUSED</h1>
        <div class="menu-item">
            <label for="distSlider">Render Distance: <span id="distVal">5</span></label><br>
            <input type="range" id="distSlider" min="2" max="16" value="5" step="1">
        </div>
        <div class="menu-item">
            <button class="btn" id="resumeBtn">RESUME</button>
        </div>
    </div>
    <div id="hotbar"></div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { createNoise2D } from 'simplex-noise';
        
        // --- POST PROCESSING IMPORTS ---
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- CONFIGURATION ---
        let renderDistance = 5;
        const CHUNK_SIZE = 16;
        const WORLD_HEIGHT = 256; 
        
        // Terrain Gen Settings
        const NOISE_SCALE = 0.0015; 
        const AMP_HEIGHT = 140;     
        const BASE_HEIGHT = 50;
        
        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls, composer;
        let sunLight, ambientLight;
        let chunkSpiralOffsets = []; 

        const chunks = new Map(); // Key is int32
        const noise2D = createNoise2D(); 
        
        // Physics
        const velocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        let isPaused = true;
        let frameCount = 0;
        
        // Optimization
        let chunkQueue = new Int32Array(2000); 
        let chunkQueueLen = 0;
        let lastChunkCheckX = -9999;
        let lastChunkCheckZ = -9999;
        const chunkCache = { key: -1, chunk: null };

        const raycaster = new THREE.Raycaster();
        const _tempVec3 = new THREE.Vector3();
        const _box3Player = new THREE.Box3();
        const _box3Block = new THREE.Box3();
        
        // Scratchpads
        const MAX_GEOM_SIZE = 500000;
        const scratchPos = new Float32Array(MAX_GEOM_SIZE * 3);
        const scratchUV = new Float32Array(MAX_GEOM_SIZE * 2);
        const scratchCol = new Float32Array(MAX_GEOM_SIZE * 3);
        const scratchNor = new Float32Array(MAX_GEOM_SIZE * 3);

        // OPTIMIZATION: Chunk Pooling & Global Buffers
        const CHUNK_POOL = [];
        const TEMP_HEIGHT_MAP = new Int16Array(32 * 32); 

        const BLOCKS = { AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, LOG: 4, LEAVES: 5, PLANKS: 6 };
        
        const BLOCK_PROPS = [
            null,
            { color: '#66FF33', name: 'Grass' }, 
            { color: '#8D6E63', name: 'Dirt' },  
            { color: '#B0BEC5', name: 'Stone' }, 
            { color: '#5D4037', name: 'Log' },   
            { color: '#76FF03', name: 'Leaves', transparent: true }, 
            { color: '#FFD54F', name: 'Planks' } 
        ];

        // OPTIMIZATION: Fast Opacity Lookup
        const OPAQUE = new Uint8Array(256);
        BLOCK_PROPS.forEach((p, i) => {
            if (i > 0 && !p.transparent) OPAQUE[i] = 1;
        });

        let selectedBlock = BLOCKS.GRASS;

        // Padded buffer constants
        const PADDED_SIZE_X = CHUNK_SIZE + 2;
        const PADDED_SIZE_Z = CHUNK_SIZE + 2;
        const PADDED_STRIDE_Z = PADDED_SIZE_X;
        const PADDED_STRIDE_Y = PADDED_SIZE_X * PADDED_SIZE_Z;
        const paddedBuffer = new Uint8Array(PADDED_SIZE_X * PADDED_SIZE_Z * WORLD_HEIGHT);

        function getChunkKey(cx, cz) {
            return (cx & 0xFFFF) << 16 | (cz & 0xFFFF);
        }

        function generateSpiralOffsets(dist) {
            const offsets = [];
            let x = 0, z = 0, dx = 0, dz = -1;
            let t = dist * 2 + 1;
            let maxI = t * t;
            
            for (let i = 0; i < maxI; i++) {
                if ((-dist <= x) && (x <= dist) && (-dist <= z) && (z <= dist)) {
                    offsets.push({x, z, d2: x*x + z*z});
                }
                if ((x === z) || ((x < 0) && (x === -z)) || ((x > 0) && (x === 1 - z))) {
                    t = dx; dx = -dz; dz = t;
                }
                x += dx; z += dz;
            }
            return offsets;
        }

        // --- TEXTURES ---
        function createTextureAtlas() {
            const size = 64; 
            const canvas = document.createElement('canvas');
            canvas.width = size * (BLOCK_PROPS.length - 1);
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            BLOCK_PROPS.forEach((block, i) => {
                if (!block) return;
                const x = (i - 1) * size;
                ctx.fillStyle = block.color;
                ctx.fillRect(x, 0, size, size);
                ctx.fillStyle = 'rgba(255,255,255,0.15)'; 
                if (block.name === 'Grass') {
                    for(let k=0; k<15; k++) ctx.fillRect(x + Math.random()*size, Math.random()*size, 3, 3);
                } else if (block.name === 'Stone') {
                    ctx.fillStyle = 'rgba(0,0,0,0.1)'; 
                    ctx.fillRect(x+15, 15, 20, 10);
                    ctx.fillRect(x+40, 40, 10, 10);
                } else if (block.name === 'Log' || block.name === 'Planks') {
                    ctx.fillStyle = 'rgba(0,0,0,0.1)'; 
                    ctx.fillRect(x+8, 12, size-16, 4);
                    ctx.fillRect(x+8, 32, size-16, 4);
                    ctx.fillRect(x+8, 52, size-16, 4);
                }
            });

            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter;
            tex.minFilter = THREE.NearestFilter;
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const atlas = createTextureAtlas(); 

        const standardMaterial = new THREE.MeshStandardMaterial({ 
            map: atlas,
            vertexColors: true,
            side: THREE.FrontSide,
            roughness: 0.8, 
            metalness: 0.1,
        });

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x4FC3F7); 
            scene.fog = new THREE.Fog(0x4FC3F7, 30, 150);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0; 
            document.body.appendChild(renderer.domElement);

            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.85;
            bloomPass.strength = 0.3; 
            bloomPass.radius = 0.5;
            composer.addPass(bloomPass);

            const outputPass = new OutputPass();
            composer.addPass(outputPass);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
            scene.add(ambientLight);

            sunLight = new THREE.DirectionalLight(0xFFFFFF, 1.4); 
            sunLight.position.set(50, 150, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024; 
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 300;
            const d = 100;
            sunLight.shadow.camera.left = -d;
            sunLight.shadow.camera.right = d;
            sunLight.shadow.camera.top = d;
            sunLight.shadow.camera.bottom = -d;
            sunLight.shadow.bias = -0.0005; 
            scene.add(sunLight);

            controls = new PointerLockControls(camera, document.body);
            
            const menu = document.getElementById('menu');
            const resumeBtn = document.getElementById('resumeBtn');
            const slider = document.getElementById('distSlider');
            const distVal = document.getElementById('distVal');

            resumeBtn.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => { menu.style.display = 'none'; isPaused = false; });
            controls.addEventListener('unlock', () => { menu.style.display = 'flex'; isPaused = true; });

            slider.addEventListener('input', (e) => {
                renderDistance = parseInt(e.target.value);
                distVal.innerText = renderDistance;
                chunkSpiralOffsets = generateSpiralOffsets(renderDistance);
                scene.fog.far = renderDistance * CHUNK_SIZE;
                
                lastChunkCheckX = -9999; 
                chunkQueueLen = 0; 
                
                const px = Math.floor(camera.position.x / CHUNK_SIZE);
                const pz = Math.floor(camera.position.z / CHUNK_SIZE);
                for (const [key, chunk] of chunks.entries()) {
                    if (Math.abs(chunk.cx - px) > renderDistance + 1 || Math.abs(chunk.cz - pz) > renderDistance + 1) {
                        releaseChunk(chunk);
                        chunks.delete(key);
                    }
                }
            });
            
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('wheel', onScroll);

            setupHotbar();
            camera.position.set(0, 150, 0); 
            
            chunkSpiralOffsets = generateSpiralOffsets(renderDistance);
            queueChunks(true); 
            animate();
            window.addEventListener('resize', onWindowResize);
        }

        function setupHotbar() {
            const hotbar = document.getElementById('hotbar');
            for(let i=1; i<BLOCK_PROPS.length; i++) {
                const div = document.createElement('div');
                div.className = 'slot' + (i === 1 ? ' active' : '');
                div.style.backgroundColor = BLOCK_PROPS[i].color;
                div.onclick = () => selectBlock(i);
                hotbar.appendChild(div);
            }
        }

        function selectBlock(index) {
            const slots = document.querySelectorAll('.slot');
            slots.forEach(s => s.classList.remove('active'));
            if(slots[index-1]) {
                slots[index-1].classList.add('active');
                selectedBlock = index;
            }
        }
        
        function onScroll(e) {
            let idx = selectedBlock - 1;
            if(e.deltaY > 0) idx = (idx + 1) % (BLOCK_PROPS.length - 1);
            else idx = (idx - 1 + (BLOCK_PROPS.length - 1)) % (BLOCK_PROPS.length - 1);
            selectBlock(idx + 1);
        }

        function getTerrainHeight(x, z) {
            let n = noise2D(x * NOISE_SCALE, z * NOISE_SCALE);
            let norm = (n + 1) * 0.5; 
            let shaped = Math.pow(norm, 2.5); 
            return Math.floor(BASE_HEIGHT + (shaped * AMP_HEIGHT));
        }

        // --- CHUNK SYSTEM ---
        class Chunk {
            constructor() {
                // ALLOCATE MEMORY ONCE
                this.cx = 0;
                this.cz = 0;
                this.data = new Uint8Array((CHUNK_SIZE * CHUNK_SIZE * WORLD_HEIGHT) / 2);
                this.mesh = null;
                // OPTIMIZATION: Track Max Y to skip Sky Loop
                this.maxY = 0;
                this.isGenerated = false;
                this.isMeshed = false;
            }

            configure(cx, cz) {
                this.cx = cx;
                this.cz = cz;
                this.data.fill(0);
                this.maxY = 0;
                this.isGenerated = false;
                this.isMeshed = false;
                if (this.mesh) {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh = null;
                }
            }

            getIndex(x, y, z) { return x + CHUNK_SIZE * (z + CHUNK_SIZE * y); }

            setBlock(x, y, z, id) { 
                if (x >= 0 && x < CHUNK_SIZE && z >= 0 && z < CHUNK_SIZE && y >= 0 && y < WORLD_HEIGHT) {
                    // Update Max Y for culling optimization
                    if (id !== BLOCKS.AIR && y > this.maxY) this.maxY = y;
                    
                    const idx = this.getIndex(x, y, z);
                    const byteIdx = idx >> 1;
                    const isOdd = idx & 1;
                    if (isOdd) this.data[byteIdx] = (this.data[byteIdx] & 0x0F) | ((id & 0x0F) << 4);
                    else this.data[byteIdx] = (this.data[byteIdx] & 0xF0) | (id & 0x0F);
                } 
            }

            getBlock(x, y, z) { 
                if (x >= 0 && x < CHUNK_SIZE && z >= 0 && z < CHUNK_SIZE && y >= 0 && y < WORLD_HEIGHT) {
                    const idx = this.getIndex(x, y, z);
                    const byteIdx = idx >> 1;
                    const isOdd = idx & 1;
                    const val = this.data[byteIdx];
                    return isOdd ? (val >> 4) : (val & 0x0F);
                }
                return 0;
            }

            generate() {
                const startX = this.cx * CHUNK_SIZE;
                const startZ = this.cz * CHUNK_SIZE;
                const buffer = 3;
                const totalSize = CHUNK_SIZE + 2 * buffer;
                
                // USE GLOBAL SCRATCHPAD instead of new Int16Array
                const heightMap = TEMP_HEIGHT_MAP;
                
                const getHeight = (lx, lz) => {
                    const idx = (lx + buffer) + totalSize * (lz + buffer);
                    return heightMap[idx];
                }

                for (let x = -buffer; x < CHUNK_SIZE + buffer; x++) {
                    for (let z = -buffer; z < CHUNK_SIZE + buffer; z++) {
                        const h = getTerrainHeight(startX + x, startZ + z);
                        const idx = (x + buffer) + totalSize * (z + buffer);
                        heightMap[idx] = h;
                    }
                }

                for (let x = 0; x < CHUNK_SIZE; x++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const h = getHeight(x, z);
                        for (let y = 0; y <= h; y++) {
                            this.setBlock(x, y, z, y === h ? BLOCKS.GRASS : (y > h - 4 ? BLOCKS.DIRT : BLOCKS.STONE));
                        }
                    }
                }
                
                for (let x = -buffer; x < CHUNK_SIZE + buffer; x++) {
                    for (let z = -buffer; z < CHUNK_SIZE + buffer; z++) {
                        const treeNoise = noise2D((startX + x) * 0.5, (startZ + z) * 0.5); 
                        if (treeNoise > 0.85) {
                            const h = getHeight(x, z);
                            if (h < WORLD_HEIGHT - 10) this.drawTree(x, h + 1, z);
                        }
                    }
                }
                this.isGenerated = true;
            }

            drawTree(lx, ly, lz) {
                const height = 5;
                for (let i = 0; i < height; i++) this.setBlock(lx, ly + i, lz, BLOCKS.LOG);
                for (let x = -2; x <= 2; x++) {
                    for (let y = height - 2; y <= height + 1; y++) {
                        for (let z = -2; z <= 2; z++) {
                            if (Math.abs(x) + Math.abs(y - (height - 1)) + Math.abs(z) <= 3) {
                                if (this.getBlock(lx+x, ly+y, lz+z) === BLOCKS.AIR) this.setBlock(lx+x, ly+y, lz+z, BLOCKS.LEAVES);
                            }
                        }
                    }
                }
            }

            buildMesh() {
                if (this.mesh) { this.mesh.geometry.dispose(); scene.remove(this.mesh); }

                let vIdx = 0, cIdx = 0, uIdx = 0, nIdx = 0;
                const numTypes = BLOCK_PROPS.length - 1;
                const uvStep = 1 / numTypes;
                const chunkCX = this.cx * CHUNK_SIZE;
                const chunkCZ = this.cz * CHUNK_SIZE;
                
                paddedBuffer.fill(0);
                
                // OPTIMIZATION: Loop only up to MaxY + Padding
                const loopLimit = Math.min(this.maxY + 2, WORLD_HEIGHT);

                // --- 1. FILL PADDED BUFFER ---
                for (let y = 0; y < loopLimit; y++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        for (let x = 0; x < CHUNK_SIZE; x++) {
                            const idx = x + CHUNK_SIZE * (z + CHUNK_SIZE * y);
                            const byteIdx = idx >> 1;
                            const isOdd = idx & 1;
                            const val = this.data[byteIdx];
                            const block = isOdd ? (val >> 4) : (val & 0x0F);
                            const pIdx = (x + 1) + (z + 1) * PADDED_STRIDE_Z + y * PADDED_STRIDE_Y;
                            paddedBuffer[pIdx] = block;
                        }
                    }
                }

                const nPX = chunks.get(getChunkKey(this.cx+1, this.cz));
                const nNX = chunks.get(getChunkKey(this.cx-1, this.cz));
                const nPZ = chunks.get(getChunkKey(this.cx, this.cz+1));
                const nNZ = chunks.get(getChunkKey(this.cx, this.cz-1));

                for (let y = 0; y < loopLimit; y++) {
                    for (let i = 0; i < CHUNK_SIZE; i++) {
                        let b;
                        b = nNX ? nNX.getBlock(CHUNK_SIZE-1, y, i) : 0;
                        paddedBuffer[0 + (i+1)*PADDED_STRIDE_Z + y*PADDED_STRIDE_Y] = b;
                        b = nPX ? nPX.getBlock(0, y, i) : 0;
                        paddedBuffer[(CHUNK_SIZE+1) + (i+1)*PADDED_STRIDE_Z + y*PADDED_STRIDE_Y] = b;
                        b = nNZ ? nNZ.getBlock(i, y, CHUNK_SIZE-1) : 0;
                        paddedBuffer[(i+1) + 0*PADDED_STRIDE_Z + y*PADDED_STRIDE_Y] = b;
                        b = nPZ ? nPZ.getBlock(i, y, 0) : 0;
                        paddedBuffer[(i+1) + (CHUNK_SIZE+1)*PADDED_STRIDE_Z + y*PADDED_STRIDE_Y] = b;
                    }
                }

                // Helper: Vertex AO
                const aoVal = (s1, s2, c) => {
                    const o1 = OPAQUE[paddedBuffer[s1]];
                    const o2 = OPAQUE[paddedBuffer[s2]];
                    const oc = OPAQUE[paddedBuffer[c]];
                    if (o1 && o2) return 0.5; 
                    const count = o1 + o2 + oc;
                    return 1.0 - (count * 0.15); 
                };

                // --- 2. BUILD MESH ---
                for (let y = 0; y < loopLimit; y++) {
                    const yOffset = y * PADDED_STRIDE_Y;
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const zOffset = (z + 1) * PADDED_STRIDE_Z;
                        for (let x = 0; x < CHUNK_SIZE; x++) {
                            
                            const bIdx = (x + 1) + zOffset + yOffset;
                            const block = paddedBuffer[bIdx];
                            if (block === 0) continue;

                            const u0 = (block - 1) * uvStep, u1 = u0 + uvStep;

                            // +X Right
                            const bRight = paddedBuffer[bIdx + 1];
                            if (bRight === 0 || !OPAQUE[bRight]) {
                                if (vIdx + 18 < MAX_GEOM_SIZE * 3) {
                                    const light = 0.8; 
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    for(let k=0; k<6; k++) { scratchNor[nIdx++] = 1; scratchNor[nIdx++] = 0; scratchNor[nIdx++] = 0; }
                                    for(let k=0; k<18; k++) scratchCol[cIdx++] = light;
                                    scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0; scratchUV[uIdx++]=u1; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=1;
                                }
                            }

                            // -X Left
                            const bLeft = paddedBuffer[bIdx - 1];
                            if (bLeft === 0 || !OPAQUE[bLeft]) {
                                if (vIdx + 18 < MAX_GEOM_SIZE * 3) {
                                    const light = 0.8;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;
                                    for(let k=0; k<6; k++) { scratchNor[nIdx++] = -1; scratchNor[nIdx++] = 0; scratchNor[nIdx++] = 0; }
                                    for(let k=0; k<18; k++) scratchCol[cIdx++] = light;
                                    scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0; scratchUV[uIdx++]=u1; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=1;
                                }
                            }

                            // +Y Top
                            let bTop = 0;
                            if (y < WORLD_HEIGHT - 1) bTop = paddedBuffer[bIdx + PADDED_STRIDE_Y];
                            if (bTop === 0 || !OPAQUE[bTop]) {
                                if (vIdx + 18 < MAX_GEOM_SIZE * 3) {
                                    // AO CALCULATION FOR TOP FACE
                                    const up = bIdx + PADDED_STRIDE_Y;
                                    const N = up - 1; 
                                    const S = up + 1; 
                                    const W = up + PADDED_STRIDE_Z; 
                                    const E = up - PADDED_STRIDE_Z; 
                                    
                                    const NW = N + PADDED_STRIDE_Z; 
                                    const NE = N - PADDED_STRIDE_Z; 
                                    const SW = S + PADDED_STRIDE_Z; 
                                    const SE = S - PADDED_STRIDE_Z; 

                                    const ao0 = aoVal(N, W, NW);
                                    const ao1 = aoVal(S, W, SW);
                                    const ao2 = aoVal(S, E, SE);
                                    const ao3 = aoVal(N, E, NE);

                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;
                                    
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;

                                    for(let k=0; k<6; k++) { scratchNor[nIdx++] = 0; scratchNor[nIdx++] = 1; scratchNor[nIdx++] = 0; }
                                    
                                    scratchCol[cIdx++] = ao0; scratchCol[cIdx++] = ao0; scratchCol[cIdx++] = ao0;
                                    scratchCol[cIdx++] = ao1; scratchCol[cIdx++] = ao1; scratchCol[cIdx++] = ao1;
                                    scratchCol[cIdx++] = ao2; scratchCol[cIdx++] = ao2; scratchCol[cIdx++] = ao2;
                                    
                                    scratchCol[cIdx++] = ao0; scratchCol[cIdx++] = ao0; scratchCol[cIdx++] = ao0;
                                    scratchCol[cIdx++] = ao2; scratchCol[cIdx++] = ao2; scratchCol[cIdx++] = ao2;
                                    scratchCol[cIdx++] = ao3; scratchCol[cIdx++] = ao3; scratchCol[cIdx++] = ao3;

                                    scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0; scratchUV[uIdx++]=u1; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=1;
                                }
                            }

                            // -Y Bottom
                            let bBot = 0;
                            if (y > 0) bBot = paddedBuffer[bIdx - PADDED_STRIDE_Y];
                            if (bBot === 0 || !OPAQUE[bBot]) {
                                if (vIdx + 18 < MAX_GEOM_SIZE * 3) {
                                    const light = 0.5; 
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    for(let k=0; k<6; k++) { scratchNor[nIdx++] = 0; scratchNor[nIdx++] = -1; scratchNor[nIdx++] = 0; }
                                    for(let k=0; k<18; k++) scratchCol[cIdx++] = light;
                                    scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0; scratchUV[uIdx++]=u1; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=1;
                                }
                            }

                            // +Z Front
                            const bFront = paddedBuffer[bIdx + PADDED_STRIDE_Z];
                            if (bFront === 0 || !OPAQUE[bFront]) {
                                if (vIdx + 18 < MAX_GEOM_SIZE * 3) {
                                    const light = 0.8;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z+1;
                                    for(let k=0; k<6; k++) { scratchNor[nIdx++] = 0; scratchNor[nIdx++] = 0; scratchNor[nIdx++] = 1; }
                                    for(let k=0; k<18; k++) scratchCol[cIdx++] = light;
                                    scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0; scratchUV[uIdx++]=u1; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=1;
                                }
                            }

                            // -Z Back
                            const bBack = paddedBuffer[bIdx - PADDED_STRIDE_Z];
                            if (bBack === 0 || !OPAQUE[bBack]) {
                                if (vIdx + 18 < MAX_GEOM_SIZE * 3) {
                                    const light = 0.8;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;
                                    scratchPos[vIdx++] = x+1; scratchPos[vIdx++] = y+1; scratchPos[vIdx++] = z;
                                    for(let k=0; k<6; k++) { scratchNor[nIdx++] = 0; scratchNor[nIdx++] = 0; scratchNor[nIdx++] = -1; }
                                    for(let k=0; k<18; k++) scratchCol[cIdx++] = light;
                                    scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0; scratchUV[uIdx++]=u1; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=0;
                                    scratchUV[uIdx++]=u1; scratchUV[uIdx++]=1; scratchUV[uIdx++]=u0; scratchUV[uIdx++]=1;
                                }
                            }
                        }
                    }
                }
                
                this.isMeshed = true;

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(scratchPos.slice(0, vIdx), 3));
                geometry.setAttribute('uv', new THREE.BufferAttribute(scratchUV.slice(0, uIdx), 2));
                geometry.setAttribute('color', new THREE.BufferAttribute(scratchCol.slice(0, cIdx), 3));
                geometry.setAttribute('normal', new THREE.BufferAttribute(scratchNor.slice(0, nIdx), 3));
                
                geometry.computeBoundingSphere();

                this.mesh = new THREE.Mesh(geometry, standardMaterial);
                this.mesh.position.set(chunkCX, 0, chunkCZ);
                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;
                
                this.mesh.matrixAutoUpdate = false; 
                this.mesh.updateMatrix();
                scene.add(this.mesh);
            }
        }

        // --- GLOBAL WORLD HELPERS ---
        
        // POOLING FACTORY
        function createChunk(cx, cz) {
            let chunk;
            if (CHUNK_POOL.length > 0) {
                chunk = CHUNK_POOL.pop();
            } else {
                chunk = new Chunk();
            }
            chunk.configure(cx, cz);
            return chunk;
        }

        function releaseChunk(chunk) {
            if (chunk.mesh) {
                scene.remove(chunk.mesh);
                chunk.mesh.geometry.dispose();
                chunk.mesh = null;
            }
            CHUNK_POOL.push(chunk);
        }
        
        function getChunk(cx, cz) {
            const key = getChunkKey(cx, cz);
            if (chunkCache.key === key) return chunkCache.chunk;
            const chunk = chunks.get(key);
            if (chunk) {
                chunkCache.key = key;
                chunkCache.chunk = chunk;
            }
            return chunk;
        }

        function isCollidableGlobal(x, y, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const chunk = getChunk(cx, cz); 
            if (!chunk) return false;
            let lx = x % CHUNK_SIZE; if(lx < 0) lx += CHUNK_SIZE;
            let lz = z % CHUNK_SIZE; if(lz < 0) lz += CHUNK_SIZE;
            const b = chunk.getBlock(lx, y, lz);
            return b !== 0;
        }

        function setBlockGlobal(x, y, z, id) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const key = getChunkKey(cx, cz);
            const chunk = chunks.get(key);
            if (chunk) {
                let lx = x % CHUNK_SIZE; if(lx < 0) lx += CHUNK_SIZE;
                let lz = z % CHUNK_SIZE; if(lz < 0) lz += CHUNK_SIZE;
                chunk.setBlock(lx, y, lz, id);
                chunk.buildMesh(); 
                // Immediate neighbor updates for interactivity
                const nW = chunks.get(getChunkKey(cx-1, cz));
                const nE = chunks.get(getChunkKey(cx+1, cz));
                const nN = chunks.get(getChunkKey(cx, cz-1));
                const nS = chunks.get(getChunkKey(cx, cz+1));
                if (lx === 0 && nW) nW.buildMesh();
                if (lx === CHUNK_SIZE - 1 && nE) nE.buildMesh();
                if (lz === 0 && nN) nN.buildMesh();
                if (lz === CHUNK_SIZE - 1 && nS) nS.buildMesh();
            }
        }

        function queueChunks(force = false) {
            const px = Math.floor(camera.position.x / CHUNK_SIZE);
            const pz = Math.floor(camera.position.z / CHUNK_SIZE);
            if (!force && px === lastChunkCheckX && pz === lastChunkCheckZ) return;
            lastChunkCheckX = px;
            lastChunkCheckZ = pz;
            chunkQueueLen = 0;
            for(let i=0; i<chunkSpiralOffsets.length; i++) {
                const offset = chunkSpiralOffsets[i];
                const cx = px + offset.x;
                const cz = pz + offset.z;
                const key = getChunkKey(cx, cz);
                if (!chunks.has(key)) {
                    // Queue for processing
                }
            }
            let removals = 0;
            const pruneDist = renderDistance + 1;
            for (const [key, chunk] of chunks.entries()) {
                if (removals > 2) break; 
                if (Math.abs(chunk.cx - px) > pruneDist || Math.abs(chunk.cz - pz) > pruneDist) {
                    releaseChunk(chunk); 
                    chunks.delete(key);
                    removals++;
                }
            }
        }

        function processChunkQueue() {
            const startTime = performance.now();
            const MAX_FRAME_TIME = 3; // Even tighter budget
            let processed = 0;
            const px = Math.floor(camera.position.x / CHUNK_SIZE);
            const pz = Math.floor(camera.position.z / CHUNK_SIZE);

            for (let i = 0; i < chunkSpiralOffsets.length; i++) {
                if (performance.now() - startTime > MAX_FRAME_TIME) break;
                
                const off = chunkSpiralOffsets[i];
                const cx = px + off.x;
                const cz = pz + off.z;
                const key = getChunkKey(cx, cz);
                
                if (chunks.has(key)) {
                    // PHASE 2: Check if meshing needed
                    const chunk = chunks.get(key);
                    if (!chunk.isMeshed && chunk.isGenerated) {
                        chunk.buildMesh();
                        
                        // Mark neighbors for potential remesh next frame?
                        // For simplicity in this demo, we assume neighbors are handled
                        // or we trigger them immediately if we have budget.
                        // Ideally we flag them "dirty" and process in loop.
                        processed++;
                    }
                } else {
                    // PHASE 1: Generate Data
                    const chunk = createChunk(cx, cz); 
                    chunks.set(key, chunk);
                    chunk.generate(); // Only generates data
                    processed++;
                }
            }
            
            // Second pass for neighbor updates to prevent holes (if budget allows)
            // Or just handle them simply when generating.
            // For this demo, we do basic neighbor meshing in the loop above if they exist.
        
            document.getElementById('queue').innerText = processed > 0 ? "Loading..." : "0";
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if(canJump) { velocity.y = 13; canJump = false; } break;
                case 'Digit1': selectBlock(1); break;
                case 'Digit2': selectBlock(2); break;
                case 'Digit3': selectBlock(3); break;
                case 'Digit4': selectBlock(4); break;
                case 'Digit5': selectBlock(5); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }
        function onMouseDown(e) {
            if(!controls.isLocked) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const meshes = [];
            for(const c of chunks.values()) if(c.mesh) meshes.push(c.mesh);
            const intersects = raycaster.intersectObjects(meshes);
            if(intersects.length > 0) {
                const hit = intersects[0];
                const bx = Math.floor(hit.point.x - hit.face.normal.x * 0.5);
                const by = Math.floor(hit.point.y - hit.face.normal.y * 0.5);
                const bz = Math.floor(hit.point.z - hit.face.normal.z * 0.5);
                if(e.button === 0) setBlockGlobal(bx, by, bz, BLOCKS.AIR);
                else if(e.button === 2) {
                    const px = Math.floor(hit.point.x + hit.face.normal.x * 0.5);
                    const py = Math.floor(hit.point.y + hit.face.normal.y * 0.5);
                    const pz = Math.floor(hit.point.z + hit.face.normal.z * 0.5);
                    _box3Player.setFromCenterAndSize(camera.position, _tempVec3.set(0.6, 1.8, 0.6));
                    _box3Block.min.set(px, py, pz);
                    _box3Block.max.set(px+1, py+1, pz+1);
                    if(!_box3Player.intersectsBox(_box3Block)) setBlockGlobal(px, py, pz, selectedBlock);
                }
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function checkWall(x, y, z) {
            const r = 0.3; 
            const levels = [y - 0.8, y + 0.1]; 
            for (let ly of levels) {
                if (isCollidableGlobal(Math.floor(x + r), Math.floor(ly), Math.floor(z + r))) return true;
                if (isCollidableGlobal(Math.floor(x - r), Math.floor(ly), Math.floor(z + r))) return true;
                if (isCollidableGlobal(Math.floor(x + r), Math.floor(ly), Math.floor(z - r))) return true;
                if (isCollidableGlobal(Math.floor(x - r), Math.floor(ly), Math.floor(z - r))) return true;
            }
            return false;
        }

        function checkFloor(x, y, z) {
            const r = 0.3;
            const yCheck = Math.floor(y - 0.01); 
            if (isCollidableGlobal(Math.floor(x + r), yCheck, Math.floor(z + r))) return true;
            if (isCollidableGlobal(Math.floor(x - r), yCheck, Math.floor(z + r))) return true;
            if (isCollidableGlobal(Math.floor(x + r), yCheck, Math.floor(z - r))) return true;
            if (isCollidableGlobal(Math.floor(x - r), yCheck, Math.floor(z - r))) return true;
            return false;
        }

        let lastFrame = performance.now();
        
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = Math.min((time - lastFrame) / 1000, 0.05); 
            lastFrame = time;
            frameCount++;
            
            sunLight.position.x = camera.position.x + 50;
            sunLight.position.z = camera.position.z + 50;
            sunLight.target.position.set(camera.position.x, 0, camera.position.z);
            sunLight.target.updateMatrixWorld();
            
            if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 32.0 * delta; 

                const speed = 150.0;
                const forward = Number(moveForward) - Number(moveBackward);
                const strafe = Number(moveRight) - Number(moveLeft);
                
                _tempVec3.setFromMatrixColumn(camera.matrix, 0); 
                if (strafe) {
                    velocity.x += _tempVec3.x * strafe * speed * delta;
                    velocity.z += _tempVec3.z * strafe * speed * delta;
                }
                _tempVec3.crossVectors(camera.up, _tempVec3);
                if (forward) {
                    velocity.x += _tempVec3.x * forward * speed * delta;
                    velocity.z += _tempVec3.z * forward * speed * delta;
                }

                const originalX = camera.position.x;
                const originalZ = camera.position.z;

                camera.position.x += velocity.x * delta;
                if (checkWall(camera.position.x, camera.position.y, camera.position.z)) {
                    camera.position.x = originalX; 
                    velocity.x = 0; 
                }

                camera.position.z += velocity.z * delta;
                if (checkWall(camera.position.x, camera.position.y, camera.position.z)) {
                    camera.position.z = originalZ; 
                    velocity.z = 0; 
                }

                camera.position.y += velocity.y * delta;
                
                if (velocity.y < 0) {
                    const feetY = camera.position.y - 1.6;
                    if (checkFloor(camera.position.x, feetY, camera.position.z)) {
                        camera.position.y = Math.floor(feetY - 0.01) + 1 + 1.6;
                        velocity.y = 0;
                        canJump = true;
                    }
                } 
                else if (velocity.y > 0) {
                    const headY = camera.position.y + 0.2;
                    if (checkWall(camera.position.x, headY, camera.position.z)) { 
                         camera.position.y = Math.floor(headY) - 0.2;
                         velocity.y = 0;
                    }
                }

                if(camera.position.y < -30) {
                    camera.position.set(0, 150, 0);
                    velocity.set(0,0,0);
                    queueChunks(true); 
                }
            }
            
            queueChunks(); 
            processChunkQueue(); 
            
            document.getElementById('fps').innerText = Math.round(1/delta);
            document.getElementById('chunks').innerText = chunks.size;
            composer.render();
        }

        init();
    </script>
</body>
</html>
